#use <conio>
#use <string>
#use <util>


typedef struct bloom_filter bloom;
struct bloom_filter {
  int limit; 
  int[] data;
};

// helper functions
int hash1(string s)
{
  int p = 31;
  int m = 1;
  for(int i = 1; i<=9; i++) {
    m = m * 10;
  } 
  m = m + 7;
  
  int n = string_length(s);
  int p_pow = 1;
  int value = 0;
  for( int i = 0; i < n; i++) {
    value = (value + 
      (1 + char_ord(string_charat(s, i)) - char_ord('a'))*p_pow) % m;
    p_pow = (p_pow * p) % m;
  }
  return value;
}

int hash2 (string s) 
{
  int n = string_length(s); 
  if (n == 0) return 0;
  if (n == 1)
  {
    return char_ord(string_charat(s, 0));
  }
  return hash2(string_sub(s, 0, n - 1)) * 31 
        + char_ord(string_charat(s, n - 1));
}


int f(int x)
{
  return 1664525 * x + 1013904223;
}

int hash3(string s) {
  int n = string_length(s);
  if (n == 0) return 0;
  if (n == 1)
  {
    return f(char_ord(string_charat(s, 0)));
  }
  return f(hash3(string_sub(s, 0, n - 1)) + char_ord(string_charat(s, n - 1)));
}



bool get_bit(int[] A, int i)
//@requires 0 <= i && i / 32 < \length(A);
{
  int array_index = i / 32;
  int bit_index = i % 32;
  int mask = 1 <<(32 - bit_index - 1);
  int bit =(A[array_index] & mask) >> (32 - bit_index - 1);
  if (bit == 0) return false;
  return true;
}


void set_bit(int[] A, int i)
//@requires 0 <= i && i/32 <\length(A);
//@ensures get_bit(A, i);
{
  int array_index = i / 32;
  int bit_index = i % 32;
  int mask = 0x1 << (32 - bit_index - 1);
  A[array_index] = A[array_index] | mask;
}



bool is_bloom(bloom* B)
//@requires B != NULL;
//@requires \length(B->data) == B->limit;
{
  return 0 < B->limit && B->limit < int_max()/8;
}

// implementation
bloom* bloom_new(int capacity)
//@requires 0 < capacity;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->limit = 1 + (capacity - 1) / 2;
  B->data = alloc_array(int, B->limit);
  return B;
}

bool bloom_contains(bloom* B, string s)
//@requires is_bloom(B);
//@ensures is_bloom(B);
{ 
  int m = 32 * B->limit;
  int idx1 = abs(hash1(s) % m);
  int idx2 = abs(hash2(s) % m);
  int idx3 = abs(hash3(s) % m);
  int[] idx_array = alloc_array(int, 3);
  idx_array[0] = idx1;
  idx_array[1] = idx2;
  idx_array[2] = idx3;
  for (int i = 0; i < 3; i ++ ) {
    if (! get_bit(B->data, idx_array[i])) return false;
  }
  return true;
}



void bloom_add(bloom* B, string s)
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, s);
{
  int m = 32 * B->limit;
  int idx1 = abs(hash1(s) % m);
  int idx2 = abs(hash2(s) % m);
  int idx3 = abs(hash3(s) % m);
  set_bit(B->data, idx1);
  set_bit(B->data, idx2);
  set_bit(B->data, idx3);
}

typedef bloom* bloom_t;
/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2023                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Extended interface of queues
 *
 * 15-122 Principles of Imperative Computation
 */

/************************************************************************/
/**************************** Client Interface **************************/

typedef void print_data_fn(void* x);            // may be useful for debugging
typedef bool check_property_fn(void* x);
typedef void* iterate_fn(void* accum, void* x);

/************************* End Client Interface *************************/
/************************************************************************/

/************************************************************************/
/************************* BEGIN IMPLEMENTATION *************************/

typedef struct list_node list;
struct list_node {
  void* data;
  list* next;
};

typedef struct queue_header queue;
struct queue_header {
  list* front;
  list* back;
  int size;
};

bool is_inclusive_segment(list* start, list* end, int i) 
{
  if (i < 0) return false;
  if (start == NULL) {
    if (i == 0) return true;
    return false;
  }
  if (start == end) {
    if (i == 1) return true;
    return false;
  }
  //@assert(start != NULL && start != end);
  return is_inclusive_segment(start->next, end, i-1);
}

bool is_queue(queue* Q) {
  return Q != NULL
      && 0 <= Q->size
      && is_inclusive_segment(Q->front, Q->back, Q->size);
}

void print_queue(queue* Q, print_data_fn* print_data) {
  list* node = Q->front;
  while (node != Q->back) {
    (*print_data)(node->data);
    node = node->next;
  }
  (*print_data)(node->data);
  return;
}

/* implementation of exported functions*/
queue* queue_new()
//@ensures is_queue(\result);
{
  queue* Q = alloc(queue);
  Q->front = NULL;
  Q->back = NULL;
  Q->size = 0;
  return Q;
}

int queue_size(queue* Q)
//@requires is_queue(Q);
//@ensures 0<= \result;
{
  return Q->size;
}

void enq(queue* Q, void* x)
//@requires is_queue(Q);
//@ensures is_queue(Q);
{
  list* node = alloc(list);
  node->data = x;
  if(Q->front == NULL) {
    Q->front = node;
    Q->back = node;
  }
  else { 
    //@assert(Q->front != NULL && Q->back != NULL);
    Q->back->next = node;
    Q->back = node;
  }
  Q->size++;
}

void* deq(queue* Q)
//@requires is_queue(Q);
//@requires 0 < Q->size; 
//@ensures is_queue(Q);
{
  list* node = Q->front;
  Q->front = Q->front->next;
  Q->size --;
  return node->data;
}

void* queue_peek(queue* Q, int i)
//@requires is_queue(Q);
//@requires 0<= i && i < Q->size;
{
  list* node = Q->front;
  while (i > 0) {
    node = node->next;
    i --;
  }
  //@assert i == 0;
  return node->data;
}

void queue_reverse(queue* Q)
//@requires is_queue(Q);
//@ensures is_queue(Q);
{
  if(Q->size == 0 || Q->size == 1) return;
  list* prev = Q->front;
  list* cur = Q->front->next;
  list* nxt = Q->front->next->next;
  while(nxt != NULL) 
  //@loop_invariant cur->next == nxt;
  {
    cur->next = prev;
    prev = cur;
    cur = nxt;
    nxt = nxt->next;
  }
  //@assert(nxt == NULL);
  cur->next = prev;

  Q->front->next = NULL;
  list* tmp = Q->front; 
  Q->front = Q->back;
  Q->back = tmp;
}


bool queue_all(queue* Q, check_property_fn* P)
//@requires is_queue(Q);
//@requires P!=NULL;
{
  list* node = Q->front;
  while (node != NULL) {
    if (! (*P)(node->data)) return false;
    node = node->next;
  }
  //@assert node == NULL;
  return true;
}

void* queue_iterate(queue* Q, void* base, iterate_fn* F)
//@requires is_queue(Q);
//@requires F!=NULL;
{
  list* tmp = Q->front;
  while (tmp != NULL) {
    base = (*F)(base, tmp->data);
    tmp = tmp->next;
  }
  //@assert tmp == NULL;
  return base;
}


// Client type
typedef queue* queue_t;

/************************** END IMPLEMENTATION **************************/
/************************************************************************/

/************************************************************************/
/*************************** Library Interface **************************/

// typedef ______* queue_t;

/* O(1) */
queue_t queue_new()
  /*@ensures \result != NULL; @*/ ;

/* O(1) */
int queue_size(queue_t Q)
  /*@requires Q != NULL; @*/
  /*@ensures \result >= 0; @*/ ;

/* O(1) -- adds an item to the back of the queue */
void enq(queue_t Q, void* x)
  /*@requires Q != NULL; @*/ ;

/* O(1) -- removes an item from the front of the queue */
void* deq(queue_t Q)
  /*@requires Q != NULL && queue_size(Q) > 0; @*/ ;

/* O(i) -- doesn't remove the item from the queue */
void* queue_peek(queue_t Q, int i)
  /*@requires Q != NULL && 0 <= i && i < queue_size(Q); @*/ ;

/* O(n) */
void queue_reverse(queue_t Q)
  /*@requires Q != NULL; @*/ ;

/* O(n) worst case, assuming P is O(1) */
bool queue_all(queue_t Q, check_property_fn* P)
  /*@requires Q != NULL && P != NULL; @*/ ;

/* O(n) worst case, assuming F is O(1) */
void* queue_iterate(queue_t Q, void* base, iterate_fn* F)
  /*@requires Q != NULL && F != NULL; @*/ ;
